<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Markdown文章自动翻译</title>
    <link href="/StaticBlog/2021/10/09/hexo-i18n-by-article-translator/"/>
    <url>/StaticBlog/2021/10/09/hexo-i18n-by-article-translator/</url>
    
    <content type="html"><![CDATA[<p>在构建个人博客时，我们经常有国际化的需求。技术上，各种博客框架都有完善的i18n解决方案，所以对博主而言最大的挑战在于内容翻译。在人工智能驱动下，机器翻译已经相当完善，满足其他语言读者阅读需求显然是没问题的，所以一个很现实的解决方案就是为自己的博客开发一个调用机器翻译API的自动翻译工具。</p><p>这个项目的地址：<a href="https://github.com/RandomNamer/MarkdownTranslator">https://github.com/RandomNamer/MarkdownTranslator</a></p><img src="image-20211012150904830.png" alt="image-20211012150904830" style="zoom:50%;" /><h1 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h1><p>为了保证翻译的准确性和可靠性，我这里选择了Google Translate API。当然，由于中国大陆特殊的网络环境，使用Google Translate的过程中还是出了不少麻烦的，虽然刚开始开发的我并不知道。</p><h2 id="试验Google-Translate会抹掉的Markdown格式"><a href="#试验Google-Translate会抹掉的Markdown格式" class="headerlink" title="试验Google Translate会抹掉的Markdown格式"></a>试验Google Translate会抹掉的Markdown格式</h2><p>这里我只试验了一些常用的markdown格式翻译，对其他特殊格式的支持会持续开发。</p><ul><li>列表项目：会把“-”和文字之间的空格去掉</li><li>代码块：会将代码块的”`”移除</li><li>行内代码：不会改动，但可能内容被更改</li><li>标题：‘#’与文字之间的空格会被去掉</li><li>数字列表项目: 不会破坏格式</li><li>斜体和粗体：不会被破坏</li><li>链接：不会被破坏</li></ul><h2 id="Google-Translate-API的获取"><a href="#Google-Translate-API的获取" class="headerlink" title="Google Translate API的获取"></a>Google Translate API的获取</h2><p>Google Translate是Google Cloud中的付费服务，虽然Google Translate在注册时自带300美元试用额度，足够个人翻译用途，但注册Google Cloud账号需要提供个人信息和国际信用卡，不够方便。这里给出一个Google翻译的客户端使用的API：<code>https://translate.google.cn/translate_a/single</code>，重要的query params主要有：</p><ul><li>sl: Source Language</li><li>tl: Destination Language</li><li>q: 要翻译的文字</li><li>tk: 翻译的Token，由原文字计算得出。<br>这里给出Token计算的一种实现：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">token</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> k = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">406644</span>;<br>    <span class="hljs-keyword">var</span> b1 = <span class="hljs-number">3293161072</span>;<br> <br>    <span class="hljs-keyword">var</span> jd = <span class="hljs-string">&quot;.&quot;</span>;<br>    <span class="hljs-keyword">var</span> sb = <span class="hljs-string">&quot;+-a^+6&quot;</span>;<br>    <span class="hljs-keyword">var</span> Zb = <span class="hljs-string">&quot;+-3^+b+-f&quot;</span>;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e = [], f = <span class="hljs-number">0</span>, g = <span class="hljs-number">0</span>; g &lt; a.length; g++) &#123;<br>        <span class="hljs-keyword">var</span> m = a.charCodeAt(g);<br>        <span class="hljs-number">128</span> &gt; m ? e[f++] = m: (<span class="hljs-number">2048</span> &gt; m ? e[f++] = m &gt;&gt; <span class="hljs-number">6</span> | <span class="hljs-number">192</span> : (<span class="hljs-number">55296</span> == (m &amp; <span class="hljs-number">64512</span>) &amp;&amp; g + <span class="hljs-number">1</span> &lt; a.length &amp;&amp; <span class="hljs-number">56320</span> == (a.charCodeAt(g + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">64512</span>) ? (m = <span class="hljs-number">65536</span> + ((m &amp; <span class="hljs-number">1023</span>) &lt;&lt; <span class="hljs-number">10</span>) + (a.charCodeAt(++g) &amp; <span class="hljs-number">1023</span>), e[f++] = m &gt;&gt; <span class="hljs-number">18</span> | <span class="hljs-number">240</span>, e[f++] = m &gt;&gt; <span class="hljs-number">12</span> &amp; <span class="hljs-number">63</span> | <span class="hljs-number">128</span>) : e[f++] = m &gt;&gt; <span class="hljs-number">12</span> | <span class="hljs-number">224</span>, e[f++] = m &gt;&gt; <span class="hljs-number">6</span> &amp; <span class="hljs-number">63</span> | <span class="hljs-number">128</span>), e[f++] = m &amp; <span class="hljs-number">63</span> | <span class="hljs-number">128</span>)<br>    &#125;<br>    a = b;<br>    <span class="hljs-keyword">for</span> (f = <span class="hljs-number">0</span>; f &lt; e.length; f++) a += e[f],<br>        a = RL(a, sb);<br>    a = RL(a, Zb);<br>    a ^= b1 || <span class="hljs-number">0</span>;<br>    <span class="hljs-number">0</span> &gt; a &amp;&amp; (a = (a &amp; <span class="hljs-number">2147483647</span>) + <span class="hljs-number">2147483648</span>);<br>    a %= <span class="hljs-number">1E6</span>;<br>    <span class="hljs-keyword">return</span> a.toString() + jd + (a ^ b)<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RL</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> t = <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-keyword">var</span> Yb = <span class="hljs-string">&quot;+&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> c = <span class="hljs-number">0</span>; c &lt; b.length - <span class="hljs-number">2</span>; c += <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">var</span> d = b.charAt(c + <span class="hljs-number">2</span>),<br>            d = d &gt;= t ? d.charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-number">87</span> : <span class="hljs-built_in">Number</span>(d),<br>            d = b.charAt(c + <span class="hljs-number">1</span>) == Yb ? a &gt;&gt;&gt; d: a &lt;&lt; d;<br>        a = b.charAt(c) == Yb ? a + d &amp; <span class="hljs-number">4294967295</span> : a ^ d<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="通过代理访问"><a href="#通过代理访问" class="headerlink" title="通过代理访问"></a>通过代理访问</h3><p><strong>注意！</strong>Node默认是不会走系统代理的，这会导致即使本机已经可以通过代理访问墙外网站，从Node发出的网络请求也还是会被阻挡在墙内。这时我们需要为Node配置代理后方可正常使用Google Translate API。但是对于很多人喜欢使用的网络请求库Axios而言，单纯使用内置的代理可能会对Google Translate这样的https站点不生效。解决方案基本有：</p><ul><li>使用ProxyAgent，如<a href="https://www.npmjs.com/package/tunnel">tunnel</a>, 而不是Axios的<code>proxy</code>。</li><li>使用修改版Axios，<code>axios-https-proxy-fix</code></li><li>使用<code>request</code></li></ul><p>一个现成的Google Translate API封装是<code>translate-google-api</code>， 可以直接通过<code>npm install translate-google-api</code>进行安装。我们可以看到其中的代码，基本上就是用axios使用刚才的API发起请求，但由于axios在https代理上存在的bug，这个模块在中国大陆基本不可用。</p><h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>这个API是为谷歌翻译的客户端提供的，因此自带反爬虫设置。一般而言，使用一个IP可以完整翻译一篇文章，但下一篇就需要切换下一个代理地址了，否则会返回错误429。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>i18n</tag>
      
      <tag>JS</tag>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pixel刷机Android 12体验</title>
    <link href="/StaticBlog/2021/10/03/pixel-android-12-exp-zh/"/>
    <url>/StaticBlog/2021/10/03/pixel-android-12-exp-zh/</url>
    
    <content type="html"><![CDATA[<p>Android 12在今年的Google I/O大会上一经推出，便如往常一样引起了全球开发者和吃瓜群众的关注。除去与iOS靠近的隐私改进和新功能之外，最重大的改变莫过于焕然一新的UI设计。无论评价如何，UI的全方位改进使得Android 12成为近几个版本Android中我们最想体验的一个。</p><p>在Google的时间表中，Android 12已经基本进入了发布阶段，基于Android 12的各种定制UI也在近期纷纷展开内测。然而第三方厂商似乎并没有拥抱Android 12最重大的改进，也就是Material You，这一充满活力、细节和优雅的UI设计系统只有在Google Pixel设备上才能完整地体验到。</p><p><img src="android-12-desktop-timeline-en-jun.svg" alt="Android 12 timeline"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Pixel</tag>
      
      <tag>Google</tag>
      
      <tag>Android 12</tag>
      
      <tag>刷机</tag>
      
      <tag>手机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Hexo和Github Pages搭建静态博客</title>
    <link href="/StaticBlog/2021/09/30/blog-with-hexo-and-gh-pages/"/>
    <url>/StaticBlog/2021/09/30/blog-with-hexo-and-gh-pages/</url>
    
    <content type="html"><![CDATA[<h1 id="用Hexo和Github-Pages搭建静态博客"><a href="#用Hexo和Github-Pages搭建静态博客" class="headerlink" title="用Hexo和Github Pages搭建静态博客"></a>用Hexo和Github Pages搭建静态博客</h1><p>个人博客曾经具有很高的门槛，因此在世纪之初时国内涌现了一大批在线博客平台。曾经搭建一个个人博客需要自己编写后端和前端，搞定域名解析服务，并付出不小数目的资金来维持它以合理的速度运行。在2021年，如果只是想体验属于自己的博客，则完全不需要这么做。对于纯静态展示用途（事实上这也是博客最基本、最重要的用途）而言，只需要一个（好看的）静态网页和一个托管平台即可。Github Pages就是这样一个托管平台，它依托于Github的Repository，使用简便，且完全不收费。我们可以直接编写静态前端，用Git推送到远端，就可以自动完成部署。Hexo就是这样一个静态博客生成工具，用它可以更简便地创建静态博客。两者结合就可以在数分钟内完成自己第一个博客的搭建。</p><h2 id="设置GitHub-Pages"><a href="#设置GitHub-Pages" class="headerlink" title="设置GitHub Pages"></a>设置GitHub Pages</h2><p>在GitHub中新建一个Repository，然后在设置中开启Github Pages托管。</p><img src="image-20210923153307744.png"  style="zoom:50%;" /><p>使用Theme-Chooser，可以生成一个缺省的页面，内容由一个Markdown文档填充。这个markdown文档也是支持嵌入HTML链接的。</p><img src="image-20210923153437095.png"  style="zoom:50%;" /><p>在简单调整之后，我们可以看到一个可以正常显示的静态网页，说明GitHub Pages已经创建成功。</p><img src="image-20210923153532574.png"  style="zoom:50%;" /><h2 id="使用Hexo生成静态博客"><a href="#使用Hexo生成静态博客" class="headerlink" title="使用Hexo生成静态博客"></a>使用Hexo生成静态博客</h2><p>Hexo是一个在Node.js上运行的工具，为了使用它，首先要确保已经安装Node.</p><img src="image-20210923153738209.png" style="zoom:50%;" /><p><code>npm</code>是Node的包管理工具，我们可以用它安装Hexo。（在macOS上，如果是第一次安装Node，npm可能缺乏文件写权限，可以使用<code>sudo chown -R $USER /usr/local/lib/node_modules</code> 为其添加权限解决。）</p><p>一切顺利的话，我们就可以使用<code>npm install -g hexo-cli</code>安装Hexo了。</p><p>安装完成后，我们就有了hexo的命令行工具，通过<code>hexo init</code>可以初始化一个博客模版：</p><img src="image-20210923160421280.png"  style="zoom:50%;" /><p>要将其编译为可用的html网页，执行<code>hexo generate </code>即可。要在浏览器预览，可以使用<code>hexo server</code>, 在本地开启一个服务器进行预览。</p><img src="image-20210923161332399.png"  style="zoom:50%;" /><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>一个简单的想法是，每次都在本地手动构建博客，然后推送到GitHub完成更新。但是我们需要将构建后的网页送往Github Pages所用的分支，而源码留在另一个分支。</p><p>这里有两种推荐的操作。</p><ul><li>得益于GitHub可以集成的CI功能，我们不必每次都手动构建，而是<strong>让CI系统帮助我们构建并发布到GitHub Pages绑定的分支</strong>。按照官网的教程：<a href="https://hexo.io/zh-cn/docs/github-pages%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%85%B3%E7%9A%84Travis">https://hexo.io/zh-cn/docs/github-pages，我们需要配置一个相关的Travis</a> CI服务。注意，Travis CI只对开源Repo有效。</li><li>所以如果想使用私有Repo托管的话，就只能使用<code>hexo-deployer-cli</code>进行部署。Hexo Deployer只需要在<code>_config.yml</code>里进行<a href="https://hexo.io/docs/one-command-deployment#Git">简单配置</a>后，每次只需要用<code>hexo clean &amp;&amp; hexo deploy</code> 即可完成部署。</li></ul><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>这里简单介绍下如何配置Deployer和在本地撰写并发布的工作流程</p><h3 id="Deployer配置和使用"><a href="#Deployer配置和使用" class="headerlink" title="Deployer配置和使用"></a>Deployer配置和使用</h3><p>要使用Deployer，只需要在<code>_config.yml</code>中配置四个项目即可，下面是一个示例配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/RandomNamer/StaticBlogTest.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span><br>  <span class="hljs-attr">message:</span> <span class="hljs-string">Update</span> <span class="hljs-string">pages</span> <span class="hljs-string">with</span> <span class="hljs-string">local</span> <span class="hljs-string">changes</span> <span class="hljs-string">on</span> &#123;&#123; <span class="hljs-string">now(&#x27;YYYY-MM-DD&#x27;)</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>只需要填入正确的repo地址，Github Pages分支和commit message即可。</p><p>deployer的操作就是先进行一次生成，再将生成的文件提交到指定的分支，commit message就是之前配置的<code>message</code>。</p><p>在部署时，只需要执行<code>hexo clean &amp;&amp; hexo d</code>即可将本地的网站与远端同步</p><h3 id="正确加载资源"><a href="#正确加载资源" class="headerlink" title="正确加载资源"></a>正确加载资源</h3><p>要让网站能正确地工作，还需要最后一步，那就是在<code>_config.yml</code>中配置网站的URL。这个URL决定了生成页面中所有链接的具体指向和加载CSS、JS和其他资源文件的路径。如果加载不当，恐怕就会是这样：</p><img src="image-20210930125831154.png"  style="zoom:50%;" /><p>正确配置之后，再执行一次（生成和）部署，正确的网页就可以在GitHub Pages上查看了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://randomnamer.github.io/</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/StaticBlogTest/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></code></pre></td></tr></table></figure><img src="image-20210930130025608.png"  style="zoom:50%;" /><h3 id="撰写文章"><a href="#撰写文章" class="headerlink" title="撰写文章"></a>撰写文章</h3><h4 id="Front-Matters"><a href="#Front-Matters" class="headerlink" title="Front Matters"></a>Front Matters</h4><p>Hexo使用markdown写作，或者说，使用Markdown的语法进行写作。Hexo有一种被称为<a href="https://hexo.io/zh-cn/docs/front-matter">Front Matter</a>的语法，用于对每篇文章进行一定程度上的自定义，如指定网页名称，嵌入封面图，指定文章作者和tag等.</p><p>Front Matter可以使用yaml撰写，也可以使用JSON撰写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2013</span><span class="hljs-string">/7/13</span> <span class="hljs-number">20</span><span class="hljs-string">:46:25</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">;;;<br><span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;Hello World&quot;</span>,<br><span class="hljs-string">&quot;date&quot;</span>: <span class="hljs-string">&quot;2013/7/13 20:46:25&quot;</span><br>;;;<br></code></pre></td></tr></table></figure><h4 id="与HTML集成"><a href="#与HTML集成" class="headerlink" title="与HTML集成"></a>与HTML集成</h4><p>如果用过Typora的话，就会对其中嵌入HTML标签的功能印象深刻，他可以让Markdown文档呈现出不属于Markdown规范的丰富样式，甚至可以通过iframe嵌入其他网页的内容。</p><img src="image-20210930143453754.png" style="zoom:50%;" /><p>Hexo也完全支持内嵌HTML，这样文章不仅可以有着丰富的自定义能力，也可以与Typora完全兼容。</p><h4 id="本地撰写实践"><a href="#本地撰写实践" class="headerlink" title="本地撰写实践"></a>本地撰写实践</h4><p>Hexo-cli提供了创建新文章的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  StaticBlogTest git:(develop) ✗ hexo new ArticleTest<br>INFO  Validating config<br>INFO  Created: ~/Documents/GitHub/StaticBlogTest/source/_posts/ArticleTest.md<br></code></pre></td></tr></table></figure><p>默认状态下，它只会在指定文件夹下创建一个markdown文件。我们可以用任何markdown编辑器进行撰写，也可以将已经撰写的markdown文件拷贝到<code>source/_posts</code>路径下，形成一篇新的文章。</p><p>在撰写完成之后，可以用<code>hexo clean &amp;&amp; hexo s</code>进行预览</p><h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><p>前端的魅力在于更便捷更自由地设计自己想要的外观，Hexo也有着丰富的自定义主题，并且也可以自己开发定制主题。</p><p>在Github上和Hexo官网上都有大量的主题</p><img src="image-20210930130535951.png" style="zoom:33%;" /><p>只需要主题下载到<code>themes</code>文件夹下，在<code>_config.yml</code>中引用这个主题的名字（文件夹名）就可以使用这个主题。不同的主题提供了丰富的配置项目，可以对其进行进一步定制。同时，所有的主题也都是使用标准前端技术构建的，也可以自己对主题进行修改和定制。</p><p>比如我这里使用的主题<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>，其文章页的目录就只能居右，通过对它的模版进行修改，可以自定义布局，在左边显示目录，同时使正文不强制居中(space-evenly)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>几个小时下来，Hexo这个静态博客生成框架还是给了我不少惊喜，首先就是文章撰写十分容易，可以直接在熟悉的Typora上完成，Front—Matter也让我可以实现对文章样式的控制。几年来全球各地开发者贡献的的模版和插件也数不胜数，很多都让人眼前一亮。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Blog</tag>
      
      <tag>Frontend</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/StaticBlog/2021/09/23/hello-world/"/>
    <url>/StaticBlog/2021/09/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
